"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pack = void 0;
const fs = require("fs-extra");
const globby = require("globby");
const path = require("path");
const ramda_1 = require("ramda");
const semver = require("semver");
const _1 = require(".");
const helper_1 = require("./helper");
const Packagers = require("./packagers");
const utils_1 = require("./utils");
function setFunctionArtifactPath(func, artifactPath) {
    const version = this.serverless.getVersion();
    // Serverless changed the artifact path location in version 1.18
    if (semver.lt(version, '1.18.0')) {
        func.artifact = artifactPath;
        func.package = Object.assign({}, func.package, { disable: true });
        this.serverless.cli.log(`${func.name} is packaged by the esbuild plugin. Ignore messages from SLS.`);
    }
    else {
        func.package = {
            artifact: artifactPath,
        };
    }
}
const excludedFilesDefault = ['package-lock.json', 'pnpm-lock.yaml', 'yarn.lock', 'package.json'];
function pack() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return __awaiter(this, void 0, void 0, function* () {
        // GOOGLE Provider requires a package.json and NO node_modules
        const isGoogleProvider = ((_c = (_b = (_a = this.serverless) === null || _a === void 0 ? void 0 : _a.service) === null || _b === void 0 ? void 0 : _b.provider) === null || _c === void 0 ? void 0 : _c.name) === 'google';
        const excludedFiles = isGoogleProvider ? [] : excludedFilesDefault;
        // Google provider cannot use individual packaging for now - this could be built in a future release
        if (isGoogleProvider && ((_f = (_e = (_d = this.serverless) === null || _d === void 0 ? void 0 : _d.service) === null || _e === void 0 ? void 0 : _e.package) === null || _f === void 0 ? void 0 : _f.individually))
            throw new Error('Packaging failed: cannot package function individually when using Google provider');
        // get a list of all path in build
        const files = globby
            .sync('**', {
            cwd: this.buildDirPath,
            dot: true,
            onlyFiles: true,
        })
            .filter((p) => !excludedFiles.includes(p))
            .map((localPath) => ({ localPath, rootPath: path.join(this.buildDirPath, localPath) }));
        if ((0, ramda_1.isEmpty)(files)) {
            console.log('Packaging: No files found. Skipping esbuild.');
            return;
        }
        // 1) If individually is not set, just zip the all build dir and return
        if (!((_j = (_h = (_g = this.serverless) === null || _g === void 0 ? void 0 : _g.service) === null || _h === void 0 ? void 0 : _h.package) === null || _j === void 0 ? void 0 : _j.individually)) {
            const zipName = `${this.serverless.service.service}.zip`;
            const artifactPath = path.join(this.workDirPath, _1.SERVERLESS_FOLDER, zipName);
            // remove prefixes from individual extra files
            const filesPathList = (0, ramda_1.pipe)((0, ramda_1.reject)((0, ramda_1.test)(/^__only_[^/]+$/)), (0, ramda_1.map)((0, ramda_1.over)((0, ramda_1.lensProp)('localPath'), (0, ramda_1.replace)(/^__only_[^/]+\//, ''))))(files);
            const startZip = Date.now();
            yield (0, utils_1.zip)(artifactPath, filesPathList, this.buildOptions.nativeZip);
            const { size } = fs.statSync(artifactPath);
            this.serverless.cli.log(`Zip service ${this.serverless.service.service} - ${(0, utils_1.humanSize)(size)} [${Date.now() - startZip} ms]`);
            // defined present zip as output artifact
            this.serverless.service.package.artifact = artifactPath;
            return;
        }
        // 2) If individually is set, we'll optimize files and zip per-function
        const packager = yield Packagers.get(this.buildOptions.packager);
        // get a list of every function bundle
        const buildResults = this.buildResults;
        const bundlePathList = buildResults.map((b) => b.bundlePath);
        let externals = [];
        // get the list of externals to include only if exclude is not set to *
        if (this.buildOptions.exclude !== '*' && !this.buildOptions.exclude.includes('*')) {
            externals = (0, ramda_1.without)(this.buildOptions.exclude, this.buildOptions.external);
        }
        const hasExternals = !!(externals === null || externals === void 0 ? void 0 : externals.length);
        // get a tree of all production dependencies
        const packagerDependenciesList = hasExternals
            ? yield packager.getProdDependencies(this.buildDirPath)
            : {};
        const packageFiles = yield globby(this.serverless.service.package.patterns);
        // package each function
        yield Promise.all(buildResults.map(({ func, functionAlias, bundlePath }) => __awaiter(this, void 0, void 0, function* () {
            const name = `${this.serverless.service.getServiceName()}-${this.serverless.service.provider.stage}-${functionAlias}`;
            const excludedFiles = bundlePathList
                .filter((p) => !bundlePath.startsWith(p))
                .map(utils_1.trimExtension);
            const functionFiles = yield globby(func.package.patterns);
            const includedFiles = [...packageFiles, ...functionFiles];
            // allowed external dependencies in the final zip
            let depWhiteList = [];
            if (hasExternals) {
                const bundleDeps = (0, helper_1.getDepsFromBundle)(path.join(this.buildDirPath, bundlePath));
                const bundleExternals = (0, ramda_1.intersection)(bundleDeps, externals);
                depWhiteList = (0, helper_1.flatDep)(packagerDependenciesList.dependencies, bundleExternals);
            }
            const zipName = `${name}.zip`;
            const artifactPath = path.join(this.workDirPath, _1.SERVERLESS_FOLDER, zipName);
            // filter files
            const filesPathList = files
                .filter(({ localPath }) => {
                // if file is present in patterns it must be included
                if (includedFiles.find(file => file === localPath)) {
                    return true;
                }
                // exclude non individual files based on file path (and things that look derived, e.g. foo.js => foo.js.map)
                if (excludedFiles.find((p) => localPath.startsWith(`${p}.`)))
                    return false;
                // exclude files that belong to individual functions
                if (localPath.startsWith('__only_') && !localPath.startsWith(`__only_${name}/`))
                    return false;
                // exclude non whitelisted dependencies
                if (localPath.startsWith('node_modules')) {
                    // if no externals is set or if the provider is google, we do not need any files from node_modules
                    if (!hasExternals || isGoogleProvider)
                        return false;
                    if (
                    // this is needed for dependencies that maps to a path (like scoped ones)
                    !depWhiteList.find((dep) => (0, helper_1.doSharePath)(localPath, 'node_modules/' + dep)))
                        return false;
                }
                return true;
            })
                // remove prefix from individual function extra files
                .map((_a) => {
                var { localPath } = _a, rest = __rest(_a, ["localPath"]);
                return (Object.assign({ localPath: localPath.replace(`__only_${name}/`, '') }, rest));
            });
            const startZip = Date.now();
            yield (0, utils_1.zip)(artifactPath, filesPathList, this.buildOptions.nativeZip);
            const { size } = fs.statSync(artifactPath);
            this.serverless.cli.log(`Zip function: ${func.name} - ${(0, utils_1.humanSize)(size)} [${Date.now() - startZip} ms]`);
            // defined present zip as output artifact
            setFunctionArtifactPath.call(this, func, path.relative(this.serviceDirPath, artifactPath));
        })));
    });
}
exports.pack = pack;
